** 제곱
// 몫

문자열
'' ~~~ '' 쌍따옴표 안에 있는 문자열 그대로, 줄바꿈-특수문자도
문자열 곱하기 가능, A * 3 =>> AAA
문자열길이 리턴 함수 len()
문자열 슬라이싱 : str[0:4:2] =>> 0~3번 인덱스까지 2간격으로, 음수간격이면 거꾸로 

포매팅 : "I eat %d asdasd" %10 ==> %d 자리에 10 , %s로 문자열도 가능 %(, , , , )로 순서대로 여러개 넣기 가능
~~% 라고 표시하고 싶으면 %d%%
%10s , %"hi" 라면 hi까지 합쳐서 총 10칸을 생성하고 hi 앞을 공백으로 채움 =>> "        hi", 공백을 뒤에 넣고 싶다면 %-10s ==> "hi        "
%0.4f =>> 소수점 4번째 자리까지 표현
"{0:*^10}".format("hi") =>> hi를 포함한 10칸에서 hi를 가운데 정렬하고 나머지 공백을 *로 채움
f'~~~ {변수1} ~~~ {변수2}' =>> 앞에 f를 넣으면 변수를 바로 넣을 수 있음, 괄호 안에서 변수 연산 가능
f'{3.13133:0.4f}' =>> 소수 4번째까지

문자열 매서드
count(a) : a 개수
find(a) : 첫 a의 인데스, 없으면 -1
"a".join("bbb") =>> babab
upper(a) : A
lower(A) : a
a.lstrip() : a의 왼쪽 공백 제거
a.rstrip() : a의 오른쪽 공백 제거
a.strip() : a의 양쪽 공백 제거
a.replace("dd", "cc") : a 문자열의 dd를 cc로 대체
a.split() : ()안의 문자를 기준으로(split(":")이라면 :을 기준으로) 문자열을 쪼갠 것을 리스트로 반환 ['aa', 'vv', ....]




리스트
a=[ 1, 'ㅇㅁㅇ', [1,2], 3], 리스트의 요소로 다른 자료형을 한번에 넣을 수 있음
리스트안의 인덱스 접근 : a[3][2]
a[1:3] : 슬라이싱, 1번부터 3번까지 참조, 재구성하지 않음. 디폴트는 끝과 끝
del a[1] : a의 1번 인덱스를 삭제하고 리스트를 재구성
del a[2:]와 같이 사용가능

리스트 매서드
문자열 매서드를 적용가능한 것 사용가능
a.append() : ()안의 것을 리스트에 추가
a.sort() : 오름차순 정렬
a.reverse() : 순서를 뒤집음
a.sort().reverse() : 내림차순 정렬
a.index(b) : b가 몇 번째 인덱스인지 반환, 없으면 오류
a.insert(0, 4) : 0번 인덱스에 4를 삽입 =>> 기존 것들 뒤로 밀림
a.remove(b) : 가장 앞의 b를 제거하고 재구성
a.pop() : 가장 뒤의 요소를 제거하고
a.extend([4,5]) : []안의 요소를 a의 요소로 뒤에 넣음
a + b : 리스트를 더해서 합칠 수 있음

튜플
b = (1,2,3), 리스트와 비슷하지만 immutable, 변경 불가능
b = 1,2,3 과 같이 가능
b = (1, ) 하나의 요소를 가진 튜플을 선언

딕셔너리
key와 value로 구성, 객체와 비슷한 개념
d = {
  key : value,
  key : value,
  key : value,
  ...
}
d['new key'] = 'k' ,k를 value로 갖는 new key 라는 키를 추가
del d['key name 1'], a['key name 2']
key로서 mutable 값 불가능

딕셔너리 매서드
d.keys() =>> key들의 집합인 dict_keys라는 객체(리스트와 유사) 반환
d.values() =>> value들의 집합인 dict_values라는 객체(리스트와 유사) 반환
d.items() =>> 튜플, (key, value)들로 이루어진 dict_items라는 객체(리스트와 유사) 반환
a.clear() =>> 딕셔너리 초기화
a.get('key name', "기본값 지정가능, 앞의 key가 존재 하지 않을 경우 반환값(옵셔널 파라미터, 안써도 됨)") =>> 해당 key의 value 반환
'key name' in d =>> d 안에 key가 있는지 확인

집합
s1 = set([1,2,3]) -> 리스트나 스트링 등을 set() 함수를 사용하여 집합으로 변환
li = [1,1,2,2,3,3,3,3]이 있을 때 li=list(set(li))를 하면 중복 제거
s1 = {1,2,3} 집합 초기화
집합은 순서가 없기 때문에 인덱싱 X, list(s1)과 같이 변형 후 인덱싱
문자열은 개별 글자(중복X)를 요소로 인식

집합 매서드
s1 & s2 , s1.intersection(s2) =>> 교집합 반환
s1 | s2, s1.union(s2) =>> 합집합 반환
s1 - s2, s1.difference(s2) =>> 차집합 반환
s1.add(값)
s1.update([여러개의 값])
s1.remove(값)

변수는 값의 주소를 가리킴
리스트의 깊은 복사 
  b = a[:]
  b = a.copy()
  from copy import copy #copy 모듈
  b = copy(a)

a,b,c=(1,2,3)  == a=1, b=2, c=3
a,b = b,a =>> a와 b 스왑
